% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.gamMRSea.r
\name{predict.gamMRSea}
\alias{predict.gamMRSea}
\title{Function for making predictions for a model containing a CReSS basis (two dimensional local smooth).}
\usage{
\method{predict}{gamMRSea}(newdata = NULL, g2k = NULL, object, type = "response", coeff = NULL)
}
\arguments{
\item{newdata}{Data frame of covariate values to make predictions to}

\item{g2k}{Matrix of distances between prediction locations and knot locations (n x k). May be Euclidean or geodesic distances.}

\item{object}{Object from a GEE or GLM model}

\item{type}{Type of predictions required. (default=\code{response}, may also use \code{link}).}

\item{coeff}{Vector of coefficients (default = NULL). To be used when bootstrapping and sampling coefficients from a distribution e.g. in \code{do.bootstrap.cress}.}
}
\value{
Returns a vector of predictions on either the response or link scale
}
\description{
This function calculates vector of predictions on the scale of the response or link.
}
\details{
Calculate predictions for a model whilst centering the CReSS bases in the same way as the fitted model. Note, if there is an offset in the model it must be called 'area'.
}
\examples{

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# offshore redistribution data
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
data(dis.data.re)
data(predict.data.re)
data(knotgrid.off)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# distance sampling
dis.data.re$survey.id<-paste(dis.data.re$season,dis.data.re$impact,sep="")
result<-ddf(dsmodel=~mcds(key="hn", formula=~1), data=dis.data.re, method="ds",
        meta.data=list(width=250))
dis.data.re<-create.NHAT(dis.data.re,result)
count.data<-create.count.data(dis.data.re)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# spatial modelling
splineParams<-makesplineParams(data=count.data, varlist=c('depth'))
#set some input info for SALSA
count.data$response<- count.data$NHAT
# make distance matrices for datatoknots and knottoknots
distMats<-makeDists(cbind(count.data$x.pos, count.data$y.pos), na.omit(knotgrid.off))
# choose sequence of radii
r_seq<-getRadiiChoices(8,distMats$dataDist)
# set initial model without the spatial term
initialModel<- glm(response ~ as.factor(season) + as.factor(impact) + offset(log(area)),
                family='quasipoisson', data=count.data)
# make parameter set for running salsa2d
salsa2dlist<-list(fitnessMeasure = 'QICb', knotgrid = knotgrid.off, 
                 knotdim=c(26,14), startKnots=4, minKnots=4,
                 maxKnots=20, r_seq=r_seq, gap=4000, interactionTerm="as.factor(impact)")
salsa2dOutput_k6<-runSALSA2D(initialModel, salsa2dlist, d2k=distMats$dataDist,
                   k2k=distMats$knotDist, splineParams=splineParams)


# make predictions on response scale
preds<-predict.gamMRSea(newdata=predict.data.re, g2k=dists, object=salsa2dOutput_k6$bestModel)

}
