---
title: "Using the Tweedie Distribution"
author: "Lindesay Scott-Hayward"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, comment='#>', 
                      message=FALSE, eval=TRUE,
                      collapse=TRUE, dev='png')
```

This document shows how to fit a model using the tweedie distribution.

# The Tweedie distribution

The variance of the tweedie distribution is parameterrised by the mean $\mu$ and the dispersion parameter $\phi$:

$$Var(y) = V(\mu)\phi = \mu^\alpha\phi$$

The following distributions can be achieved by specifiying the following values for $\alpha$ 

- Gaussian ($\alpha = 0$)
- Poission ($\alpha = 1$)
- Gamma ($\alpha = 2$)
- Inverse Gaussian ($\alpha = 3$)

For zero inflated data, i.e. the response distribution has mass at zero (i.e., it has exact zeros) but is otherwise continuous on the positive real numbers, the values of $\alpha$ between 1 and 2 are particularly useful to us. 

## An example of fitting the tweedie distribution in `R`

```{r, eval=FALSE}
library(statmod)
glm(y ~ x, data=data, 
    family=tweedie(var.power = 1.1, link.power=0))
```

In this example, $\alpha = 1.1$ and the model can be described as:

$$y_i \sim Tw(\mu_{i}, \phi, \alpha)$$

where $$log(\mu_i) = \beta_0 + \beta_1x_i$$


and $$ Var(y_i) = \mu_i^{1.1} \phi$$

`var.power` specifies the value for $\alpha$ and `link.power = 0` indicates a log link is used.

For example, `tweedie(var.power=1, link.power=0)` is equivalent to `quasipoisson(link="log")`. Note: it is not equivalent to `poisson(link="log")` as the dispersion is not set equal to 1.


## Setup

- Load some data
- Fit a simple intercept only model and show the link between `tweedie` and `quasipoisson`.

```{r}
library(MRSea)
library(dplyr)
library(ggplot2)
```


```{r}
# load data
data(ns.data.re)
```

```{r}
library(statmod)
library(tweedie)
```

Fit a Tweedie model with $\alpha = 1$ and a log link function.
```{r}
fit_tw<- glm(birds ~ 1, family=tweedie(var.power=1, link.power = 0),data=ns.data.re)
summary(fit_tw)
```

Fit the equivalent model using the quasipoisson distribution.
```{r}
fit_qp<- glm(birds ~ 1, family=quasipoisson(link="log"),data=ns.data.re)
summary(fit_qp)
```

```{r}
profout <- tweedie.profile(birds ~ 1, 
                           data=ns.data.re,
                           xi.vec = seq(1.01, 1.99, by=0.05))
```

```{r}
profout2 <- tweedie.profile(birds ~ MonthOfYear + x.pos + y.pos + Year, 
                           data=ns.data.re,
                           xi.vec = seq(1.01, 1.99, by=0.05), do.plot=TRUE)
```

```{r}
varlist=c('MonthOfYear')
```

```{r}
initialModel<- glm(response ~ 1, family=tweedie(var.power=profout2$xi.max, link.power = 0),data=ns.data.re)
```

```{r}
# set some input information for SALSA
salsa1dlist<-list(fitnessMeasure = 'AICtweedie', 
                  minKnots_1d = c(1), 
                  maxKnots_1d = c(3), 
                  startKnots_1d = c(1), 
                  degree = c(2),
                  gaps = c(0),
                  splines = c("bs"))
```


```{r}
# run SALSA
salsa1dOutput<-runSALSA1D(initialModel, 
                          salsa1dlist, 
                          varlist = varlist, 
                          datain = ns.data.re,
                          suppress.printout = TRUE)

```

```{r}
summary(salsa1dOutput$bestModel)
```

```{r}
AICtweedie(salsa1dOutput$bestModel)
```


```{r}
runPartialPlots(salsa1dOutput$bestModel, data=ns.data.re, 
                varlist.in = varlist, showKnots = TRUE)
```


# Two dimensional Smoothing

## Starting point

This is the same starting point for one dimensional splines if it is only a two dimensional smooth you want. 

- Load some data
- Fit an initial model.  For simplicity we fit an intercept only model.

```{r}
# load data
baselinedata <- filter(nysted.analysisdata, impact == 1, season == 1)
```

```{r}
initialModel<- glm(response ~ 1, family='quasipoisson',data=baselinedata)
```


```{r}
kg <- getKnotgrid(baselinedata[, c("x.pos", "y.pos")], numKnots = 300, plot = TRUE)
```

```{r}
# make distance matrices for datatoknots and knottoknots
distMats<-makeDists(baselinedata[, c("x.pos", "y.pos")], kg)
```

```{r}
# make prediction distance matrix. 
preddata <- filter(nysted.predictdata, impact == 0, season == 1)
p2k <-makeDists(preddata[, c("x.pos", "y.pos")], kg, knotmat = FALSE)$dataDist
```



## Default: Gaussian Radial Basis

This uses a Gaussian radial basis implemented using `LRF.g()`.  It is the default and does not need to be specified. 

```{r}
# make parameter set for running salsa2D
salsa2dlist<-list(fitnessMeasure = 'QBIC', 
                  knotgrid = na.omit(kg),
                  startKnots=10, 
                  minKnots=2, 
                  maxKnots=20, 
                  gap=0)
```

```{r}
salsa2dOutput<-runSALSA2D(initialModel,
                          salsa2dlist, 
                          d2k=distMats$dataDist,
                          k2k=distMats$knotDist,
                          basis = "gaussian", ##
                          suppress.printout = TRUE)

```

```{r}
preddata$preds.g <- predict(object = salsa2dOutput$bestModel, 
                            newdata = preddata, g2k = p2k)

ggplot() +
  geom_tile(data=preddata, aes(x.pos, y.pos, fill=preds.g, 
                               height=sqrt(area), width=sqrt(area))) + 
  xlab("Easting (km)") + ylab("Northing (km)") + coord_equal() +
  theme_bw() + ggtitle("Gaussian Basis") +
  scale_fill_distiller(palette = "Spectral",name="Animal Counts")
```

## Exponential Basis

This uses an exponential radial basis implemented using `LRF.e()`.  It is more peaked at the knot than the gaussian and for this reason I have used a larger number of start knots. 

```{r}
# make parameter set for running salsa2D
salsa2dlist<-list(fitnessMeasure = 'QBIC', 
                  knotgrid = na.omit(kg),
                  startKnots=10, ##
                  minKnots=2, 
                  maxKnots=20, 
                  gap=0)
```

```{r}
salsa2dOutput.exp<-runSALSA2D(initialModel,
                          salsa2dlist, 
                          d2k=distMats$dataDist,
                          k2k=distMats$knotDist,
                          basis = "exponential", ##
                          suppress.printout = TRUE)

```

```{r}
preddata$preds.e <- predict(object = salsa2dOutput.exp$bestModel, 
                            newdata = preddata, g2k = p2k)

ggplot() +
  geom_tile(data=preddata, aes(x.pos, y.pos, fill=preds.e,
                               height=sqrt(area), width=sqrt(area))) + 
  xlab("Easting (km)") + ylab("Northing (km)") + coord_equal() +
  theme_bw() + ggtitle("Exponential Basis") +
  scale_fill_distiller(palette = "Spectral",name="Animal Counts")

```

## Raw data for reference

```{r}
ggplot() +
     geom_tile(data=baselinedata, aes(x.pos, y.pos, fill=response, height=sqrt(area), width=sqrt(area))) + 
     xlab("Easting (km)") + ylab("Northing (km)") + coord_equal() +
     theme_bw() + ggtitle("Raw Data") +
     scale_fill_distiller(palette = "Spectral",name="Animal Counts")
```

